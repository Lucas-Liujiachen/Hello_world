# \[Makefile学习笔记\]

## 一、简介

**makefile是一个对工程文件进行自动化编译的工具。**
makefile本质是一个文件，需要配合make指令来进行自动化编译。
make是一个命令工具，用来解释makefile中的代码，从而实现自动化编译，其使用的编译器仍然是gcc。
makefile文件中定义了一些规则来指定，哪些文件先编译，哪些文件后编译，哪些文件需要重新编译等等。
makefile文件一般命名为makefile或者Makefile。

## 二、原理

基本原来：若想生成目标文件，检查规则中所有依赖文件是都存在。

**依赖文件不存在：**

1. 若有的依赖文件不存在，那么则向下搜索，看看有没有规则来生成该目标文件。
2. 若有规则来生成依赖文件，那么按照该规则命令来生成依赖文件。
3. 若没有规则来生成该依赖文件，则报错。

**依赖文件存在：**

若依赖文件都存在，检查规则中的目标是否需要更新，必须先检查它所有的依赖，以来中任何一个被更新，则目标文件必须被更新

## 三、基本规则

### 1. makefile规则三要素

1. 目标：要生成的目标文件
2. 依赖：目标文件由那些文件生成
3. 命令：通过执行该命令由依赖文件生成目标

### 2. 基本规则

```makefile
目标：依赖
    命令     #其中命令必须以TAB键开始
```

```makefile
main:main.c test.c
    gcc main.c test.c -o main
```

### 3. 变量

makefile中的变量类似C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使得makefile易于维护。

1. 普通变量
2. 自动变量
3. 自带变量

#### 3-1 普通变量

普通变量的定义使用"="：

```makefile
OBJS = main     #定义并赋值
$(OBJS)         #使用变量（取值）
```

#### 3-2 自动变量

&#10052;`$@`: 规则中的目标集合，在模式规则中，如果有多个目标的话，"\$@"表示匹配模式中定义的目标集合。

&#10052;`$<`：依赖文件集合中的第一个文件，如果依赖文件是以模式(即"\%")定义的，那么"\$<"就是符合模式的一系列的文件集合

&#10052;`$^`：所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件，会去除重复的依赖文件，只保留一份。

&#10052;`$%`：当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空。

&#10052;`$?`：所有比目标新的依赖目标集合，以空格分开。

&#10052;`$+`：和"\$^"类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。

`app: main.c func1.c fun2.c gcc $^ - o $@`
其中：`$^`表示main.c func1.c fun2.c，`$<`表示main.c，`$@`表示app。

#### 3-3 系统自带变量

系统自带变量通常都是大写，比如CC、PWD、CFLAG等
有些自带变量有默认值，比如：

&#10052;CPPFLAGS：预处理器需要的选项，如：-I

&#10052;CFLAGS：编译时使用的参数，如： -Wall -g -c

&#10052;LDFLAGS：链接库使用的选项，如： -L -l

变量的默认值是可以修改的比如CC的默认值是cc，但是可以修改为gcc：CC=gcc

### 4 其他常用规则

1. `:=` ：一个变量在定义并赋值后，不会使用后面给该变量赋值的值，只能使用前面已经定义好的
2. `?=` ：如果该变量在前面没有被赋值，就给该变量赋值。如果赋值过了，就使用之前赋值的值
3. `+=` ：需要给前面已经定义好的变量添加一些字符串进去，类似`x+=1`;
4. `%` ：类似通配符，例`%.c`，也就是 `.c`结尾的所有文件
5. `\` `：是makefile中行的分隔符

例如：
`%.o:%.c  $(CC)  -c $< -o $@`
这个例子规则表示：
`main.o`由`main.c`生成，`func1.o`由`func1.c`生成，`func2.o`由`func2.c`生成。
利用`%`模式规则可以一次匹配目录下面所有的文件。

## 四、函数

注意：**Makefile中的所有函数都必须有返回值**

### 4-1 通配符 *

通配符用于查找脂肪目录下指定类型的文件，跟参数就是目录+文件类型，比如：
`src = $(wildcard ./src/*.c)`
这行命令表示：找到`./src`目录下所有后缀为`.c`的文件，并赋值给变量`src`。

### 4-2 subst

作用：字符串替换。

```makefile
$(subst <from>,<to>,<text>)
#from：字符串中被替换的字符串
#to：替换的字符串
#text：字符串

#举例
$(subst aaa,AAA,aaabbb)
#也就是将字符串aaa替换成AAA，替换后字符串为AAAbbb
```

### 4-3 patsubst

作用：模式字符串替换

```makefile
$(patsubst <pattern>,<replacement>,<text>)
#pattern：字符串中被替换的字符串的模式
#replacement：替换的字符串的模式
#text：字符串

$(patsubst %.c,%.o,a.c b.c c.c)
#将字符串“ a.c b.c c.c”中的所有符合“ %.c”的字符串，替换为“ %.o”，替换完成以后的字符串为“ a.o b.o c.o”
```

### 4-4 dir

作用：获取目录

```makefile
$(dir <names…>)

$(dir </src/a.c>)
#提取文件“ /src/a.c”的目录部分，也就是“ /src”
```

### 4-5 notdir

作用：获得文件名

```makefile
$(notdir <names…>)

$(notdir </src/a.c>)
#提取文件“ /src/a.c”中的非目录部分，也就是文件名“ a.c”。
```

### 4-6 foreach

作用：完成循环

```makefile
$(foreach <var>, <list>,<text>)
#把参数<list>中的单词逐一取出来放到参数<var>中，然后再执行<text>所包含的表达式。每次<text>都会返回一个字符串，循环的过程中，
# <text>中所包含的每个字符串会以空格隔开，最后当整个循环结束时， <text>所返回的每个字符串所组成的整个字符串将会是函数 foreach
# 函数的返回值。
```

### 4-7 wildcard

作用：在makefile规则中，它可以让通配符自动展开，可以在变量的定义和函数的引用时不让通配符失效，展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。假如不存在任何符合此模式的文件，函数会忽略模式字符并返回空。

```makefile
$(wildcard PATTERN...)
```
